//Universal commands

float dist(float p1[], float p2[]){
	float d = 0;
	for(int i=0; i < 3; i++){
		d += (p2[i]-p1[i]) * (p2[i]-p1[i]);
	}
	return sqrtf(d);
}

void dilateValue(float pt1[3], float pt2[3], float dilation , float dst[3]){
	//pt1 is starting point (anchor)
	//pt2 is second point along the line
	//dilation will scale out from pt2 away or towards pt1
	//Sets dst to be destination/target
	for(int i=0; i < 3; i++){
		dst[i] = dilation * (pt1[i] - pt2[i]) + pt1[i];
	}
}

void goToLoc(ZRState state, float dest[3], float smoothness){
	//You should run getMyZRState a few lines before this
	//state is your ZRState (a 12 element array)
	//Smoothness is a multiplier on the array. Optimal range: 0.15-0.35
	float val[3];
	mathVecSubtract(val, dest, state , 3);
	for(int i=0; i<3; i++){
		val[i] *= smoothness;
	}
	api.setVelocityTarget(val);
}

// CoronaSpheres specific commands:
//Put /* */ around if not using

void curvedPath(float start[3] , float end[3] , float currSpeed[3] , float leniency){
	/*
		Go in an elliptical path by
		1) Creating a waypoint as an outer bound 'mirror'
		2) Using goToLoc with varying speeds
		3) Go to a destination point at the same time, resulting in a curve
		4) 2 states: Before waypoint and After waypoint
	*/
	//START DENOTES YOUR LOCATION!!!
	//crt waypoint 1 #netlogo
	float waypoint[3] origin[3] bufferArr1[3] bufferArr2[3];
	origin[0] = 0.0f;
	origin[1] = 0.0f;
	origin[2] = 0.0f;
	mathVecSubtract(bufferArr1 , end , start , 3);
	mathVecSubtract(bufferArr2 , start , origin , 3);
	float angleFromSlope;
	angleFromSlope = mathVecInner(bufferArr2 , bufferArr1 , 3) / mathVecInner(bufferArr1 , bufferArr1 , 3);
	//Apply angles into buffer
	for(int i = 0; i < 3; i++){
		bufferArr1[i] *= angleFromSlope;
	}
	mathVecSubtract(bufferArr1 , bufferArr2 , bufferArr1 , 3);
	if (mathVecMagnitude(bufferArr1,3) < leniency){
		for(int i=0; i<3; i++){
			if(bufferArr1[i] >= 0){
				waypoint[i] = bufferArr1[i] * (leniency / mathVecMagnitude(bufferArr1,3)) + 0.05;
			}
			else{
				waypoint[i] = bufferArr1[i] * (leniency / mathVecMagnitude(bufferArr1,3)) - 0.05;
			}
		}
		mathVecSubtract(currSpeed , waypoint , start , 3);
	}
	float bufferArr3[];
	mathVecSubtract(bufferArr3 , waypoint , start , 3);
	else{
		mathVecSubtract(bufferArr2 , end , start , 3);
		float distance;
		distance = mathVecMagnitude(bufferArr2 , 3);
		if (distance > mathVecMagnitude(bufferArr3 , 3)({
			
		}
	}
	bool goingToWaypoint;
	goingToWaypoint = true;
	if (goingToWaypoint) {
		//
	}
	else {

	}
}
